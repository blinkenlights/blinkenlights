/* 
 * This file is part of BMix.
 *
 *    BMix is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 * 
 *    BMix is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with BMix.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

package de.blinkenlights.bmix.mixer;

import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;

/**
 * This class is a viewport to an image source used for creating outputs
 * from the main mixdown buffer.
 */
public class BLImageViewport implements BLImage {
    private final BLImage source;
    private final BufferedImage sourceImage;
    private final Rectangle viewport;
    private final int screenId;
    
    /**
     * Bits per pixel for {@link #getNetworkBytes()}. Must be 4 or 8.
     */
    private final int bpp;

    /**
     * Creates a new BLImageViewport
     * 
     * @param source
     *            the source image to use
     * @param viewport
     *            the Rectangle specifying the rectangle for this viewport
     * @param bpp
     *            the number of bits per pixel in the network data generated by
     *            {@link #getNetworkBytes()}. Only makes sense when this is a viewport
     *            of a MCU_MULTIFRAME output. Valid values are 4 and 8.
     */
    public BLImageViewport(BLImage source, Rectangle viewport, int bpp, int screenId) {
        this.source = source;
        this.sourceImage = new BufferedImage(source.getImageWidth(), source.getImageHeight(), BufferedImage.TYPE_INT_ARGB);
        this.viewport = viewport;
        this.bpp = bpp;
        if (screenId > 255 || screenId < 0) {
        	throw new IllegalArgumentException("screenId must be between 0 and 255, got "+screenId);
        }
        this.screenId = screenId;
        checkBPP(bpp);
    }

    private void checkBPP(int bpp) {
        if (bpp != 4 && bpp != 8) {
            throw new IllegalArgumentException("Bad bpp value: " + bpp + " (expected 4 or 8)");
        }
    }

    /**
     * Fills bi with the cropped version of the image this viewport wraps.
     */
    public void fillBufferedImage(BufferedImage bi) {
        source.fillBufferedImage(sourceImage);
        Graphics2D big = bi.createGraphics();
        big.drawImage(
                sourceImage,
                0, 0, viewport.width, viewport.height,
                viewport.x, viewport.y, viewport.x + viewport.width, viewport.y + viewport.height,
                null);
        big.dispose();
    }

    /**
     * Returns the viewport's height.
     */
    public int getImageHeight() {
        return viewport.height;
    }

    /**
     * Returns the viewport's width.
     */
    public int getImageWidth() {
        return viewport.width;
    }
    
    /**
     * Returns a copy of this viewport's geometry.
     */
    public Rectangle getViewport() {
		return new Rectangle(viewport);
	}
    
    /**
     * Returns the number of bits per pixel this viewport should have
     * when being sent via MCU_MULTIFRAME packets.
     */
    public int getBpp() {
        return bpp;
    }
    
    /** 
     * Returns this viewport's screen id parameter, which should be included in the 
     * MCU_MULTIFRAME packets.
     */
    public int getScreenId() {
		return screenId;
	}

	@Override
    public String toString() {
        return "viewport " + viewport;
    }
}
