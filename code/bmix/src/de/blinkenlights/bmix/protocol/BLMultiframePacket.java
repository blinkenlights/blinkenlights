package de.blinkenlights.bmix.protocol;

import java.awt.Color;

import de.blinkenlights.bmix.mixer.BLImage;
import de.blinkenlights.bmix.network.BLPacketReceiver.AlphaMode;

public class BLMultiframePacket extends BLFramePacket {

	/**
	 * Bits per pixel for {@link #getNetworkBytes()}. Must be 4 or 8.
	 */
	private final int bpp;

	/**
	 * Creates a new BLFramePacket.
	 * 
	 * @param width
	 *            the width in pixels
	 * @param height
	 *            the height in pixels
	 * @param bpp
	 *            the number of bits per pixel in the network data generated by
	 *            {@link #getNetworkBytes()}. Valid values are 4 and 8.
	 * @param pixelData
	 *            the pixel data. Must not be null, and must have length of
	 *            {@link #width} {@link #height} {@link #channels}.
	 * @param alphaMode
	 *            The method for converting pixels from the network format to
	 *            our standard 32-bit ARGB format.
	 * @param transparentColour
	 *            The colour in the input that should be treated as transparent.
	 *            If not using {@link AlphaMode#CHROMA_KEY}, pass in null for
	 *            this parameter, because it is ignored.
	 * @param shadowColour
	 *            Fully-transparent pixels in the image will appear as this
	 *            colour instead. If no translation is desired, this value
	 *            should be set to null.
	 */
	public BLMultiframePacket(int width, int height, int bpp, byte pixelData[],
			AlphaMode alphaMode, Color transparentColour, Color shadowColour) {
		super(width, height, pixelData, alphaMode, transparentColour, shadowColour);
		this.bpp = bpp;
		checkBPP(bpp);
	}

	private void checkBPP(int bpp) {
		if (bpp != 4 && bpp != 8) {
			throw new IllegalArgumentException("Bad bpp value: " + bpp + " (expected 4 or 8)");
		}
	}

	/**
	 * Creates a new BLFramePacket.
	 * 
	 * @param image
	 *            the image to use for the data
	 * @param bpp
	 *            the number of bits per pixel in the network data generated by
	 *            {@link #getNetworkBytes()}. Valid values are 4 and 8.
	 */
	public BLMultiframePacket(BLImage image, int bpp) {
		super(image);
		this.bpp = bpp;
		checkBPP(bpp);
	}

	@Override
	public byte[] getNetworkBytes() {
		int pixelBytes = getImageHeight() * getImageWidth();
		if(bpp == 4) pixelBytes = (getImageHeight() * (getImageWidth() + 1) / 2);
		byte buf[] = new byte[18 + pixelBytes];
		int offs = 0;
		buf[offs++] = 0x23;
		buf[offs++] = 0x54;
		buf[offs++] = 0x26;
		buf[offs++] = 0x68;
		long now = System.currentTimeMillis();
		for (int i = 7; i >= 0; i--) {
			buf[offs++] = (byte) ((now >> 8*i) & 0xff);
		}
		buf[offs++] = (byte) 0;   // screen id (we support only one screen currently)
		buf[offs++] = (byte) (bpp & 0xff);

		// height (16-bit)
		buf[offs++] = (byte) ((getImageHeight() >> 8) & 0xff);
		buf[offs++] = (byte) (getImageHeight() & 0xff);

		// width (16-bit)
		buf[offs++] = (byte) ((getImageWidth() >> 8) & 0xff);
		buf[offs++] = (byte) (getImageWidth() & 0xff);

		for (int j = 0; j < getImageHeight(); j++) {
			if (bpp == 4) {
				for (int i = 0; i < getImageWidth(); i += 2) {
					int left = pixelData[i + (j * getImageWidth())] >> 4;
					int right;
					if(i + 1 < getImageWidth()) {
						right = pixelData[i + (j * getImageWidth()) + 1] >> 4;
					} else {
						right = 0;
					}
					buf[offs++] = (byte)((left << 4 | (right & 0x0f)) & 0xff);
				}
			}
			if (bpp == 8) {
				for (int i = 0; i < getImageWidth(); i++) {
					buf[offs++] = pixelData[i + (j * getImageWidth())];
				}
			}
		}
		return buf;
	}
}
